# CLAUDE 开发规范

## 🎯 沟通原则

### 基础交流规范
- **语言要求**：所有内容必须使用中文思考和交流（包括代码注释）
- **表达标准**：清晰、技术准确，拒绝客套，做到非技术人员也能看懂
- **上下文解释**：始终解释指令背后的动机和原因，帮助理解"为什么"这样做

### 需求确认流程
当用户表达诉求时，必须按以下顺序思考：

1. **需求理解确认**
   ```text
   基于现有信息，我理解您的需求是：[条理化的重述需求]
   请确认我的理解是否准确？
   ```

2. **第一性原理质疑**
   从架构原则角度质疑需求合理性：
   - 如果实现了单一真相源，该需求是否还必要？
   - 如果采用纯函数计算，是否有更优解？
   - 如果集中处理副作用，问题是否已解决？

3. **思考后行动**
   ```text
   让我仔细从根源思考最佳实现方案，避免在脆弱的基础上解决问题，然后提供具体的行动计划。
   ```

## 🏗️ 架构原则

### 需求表达层（Demand Layer）
**职责**：组件直接表达数据需求和动作意图，系统自动发现和满足需求

**设计动机**：传统的命令式编程让组件承担过多职责，导致耦合度高、难以维护。需求表达层让组件专注于"要什么"，而非"怎么做"。

**实现原则**：
- ✅ **应该做**：使用语义化路径表达需求 `demand('/user/profile')`
- ❌ **避免做**：直接调用API或操作状态 `fetchUserProfile()`

<details>
<summary>示例对比</summary>

**效果较差：**
```typescript
// 组件直接处理数据获取
const UserProfile = () => {
  const [user, setUser] = useState(null);
  useEffect(() => {
    fetchUser().then(setUser);
  }, []);
  return <div>{user?.name}</div>;
};
```

**效果更好：**
```typescript
// 组件只表达需求
const UserProfile = () => {
  const user = useDemand('/user/profile');
  return <div>{user?.name}</div>;
};
```
</details>

### 需求管理层（Demand Manager）
**职责**：维护单一真相源，智能管理数据获取和状态同步

**设计动机**：避免状态分散和数据不一致问题，通过集中管理实现可预测的状态变更。

**核心保证**：
- 所有进入纯函数的数据都是不可变的
- 所有从纯函数产生的状态都是全新对象
- 需求管理器本身无副作用，只负责协调

### 纯计算层（Pure Functions）
**职责**：根据 `(previousState, demandPayload)` 输出确定的 `(nextState, derivedResult)`

**设计动机**：纯函数具有引用透明性，便于测试、调试和并行处理，是系统可靠性的基石。

**严格要求**：
- 相同输入永远产生相同输出
- 不修改输入参数
- 不产生可观察副作用（IO、日志、随机数、时间等）

### 副作用执行器（Effects Middleware）
**职责**：集中处理与外部世界的交互（HTTP、WebSocket、文件、localStorage等）

**设计动机**：将副作用从业务逻辑中分离，保证计算层的纯净性，便于测试和维护。

## 📊 状态归属判断标准

按优先级顺序判断：
1. **跨组件共享？** → 是 → 全局状态
2. **需要持久化？** → 是 → 全局状态
3. **触发副作用？** → 是 → 全局状态
4. **其他情况** → 组件内部状态

## 🏛️ 模块化原则

- **功能内聚**：相关功能聚合在同一模块，按功能而非技术分层组织代码。
- **目录结构**：features/[功能]/ 和 shared/[功能]/ 都按功能分组，清晰的依赖层次。
- **模块通信**：通过需求表达松耦合通信，避免直接依赖。
- **标准化结构**：所有模块遵循统一的内部组织原则和接口规范。
- **生命周期管理**：利用现有的模块注册、初始化、依赖验证的标准化流程。

## 🎯 行动原则

1. 为了最大效率，当您需要执行多个独立操作时，同时调用所有相关工具，而不是按顺序调用。
2. 为了最大效率，当您拆分出 todos 后，创建多个子 agent 分配不同的 todo 任务，而不是顺序执行。
2. 为了最大效率，每当质疑需求的时候，创建多个子 agent 分配不同的原则来进行思考，而不是顺序思考。
3. 注释只用来解释代码"为何"这样写，特别聚焦那些复杂或不明显、或者易于出错的逻辑。